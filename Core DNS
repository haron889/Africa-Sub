Perfect choice ğŸ‘
These two steps are core Stripe DNA. Weâ€™ll do them properly and practically, not theory.
STEP 4 â€” M-Pesa Flow Diagrams (Real, Buildable)
Below are exact flows your backend should follow. You can literally code from this.
4.1 M-Pesa STK Push â€” End-to-End Flow
Actors
Client App (Frontend)
Paycraft API (You)
M-Pesa Provider (via PSP)
Customer Phone
Flow (Step-by-Step)
Copy code

1. Client â†’ Paycraft API
   POST /v1/payments
   { amount, phone, reference }

2. Paycraft
   - Validate request
   - Create payment record (status = pending)
   - Generate idempotency key

3. Paycraft â†’ PSP â†’ M-Pesa
   STK Push request

4. M-Pesa â†’ Customer Phone
   "Enter PIN to pay KES 1500"

5. Customer
   - Confirms OR cancels

6. M-Pesa â†’ PSP â†’ Paycraft (callback)
   Payment result

7. Paycraft
   - Verify signature
   - Update payment status
   - Emit webhook event

8. Paycraft â†’ Merchant Webhook
   payment.successful OR payment.failed
Key Design Decisions (Very Important)
âœ” Never trust M-Pesa blindly
âœ” Always verify callbacks
âœ” Webhooks are source of truth, not polling
4.2 Payment State Machine (Stripe-Style)
Copy code

created
  â†“
pending
  â†“
successful  â†’ final
failed      â†’ final
expired     â†’ final
Rules:
successful is irreversible
expired happens after STK timeout (e.g. 5 min)
No silent state changes
4.3 Retry & Idempotency (Critical in Kenya)
Why?
Networks fail
Callbacks duplicate
Users retry
How Stripe Does It (You copy this)
Every request includes:
Copy code
Http
Idempotency-Key: uuid
Same key = same result
No double charges
4.4 What NOT to Do
âŒ Do not block API waiting for M-Pesa
âŒ Do not rely on frontend polling
âŒ Do not assume callbacks arrive once
STEP 5 â€” Sandbox Logic (This Is Your Secret Weapon)
Stripeâ€™s sandbox is why developers love it.
Youâ€™ll replicate the same feeling.
5.1 Test vs Live Mode (Hard Separation)
API Keys
Mode
Key
Sandbox
sk_test_xxx
Live
sk_live_xxx
Rule:
If key starts with sk_test, never call real M-Pesa
5.2 Fake Payment Engine (Core Idea)
Instead of M-Pesa, sandbox uses rules.
Test Phone Numbers
Copy code
Txt
254700000001 â†’ successful
254700000002 â†’ insufficient_funds
254700000003 â†’ user_cancelled
254700000004 â†’ timeout
5.3 Sandbox Payment Flow
Copy code

1. Client â†’ /v1/payments (test key)

2. Paycraft Sandbox Engine
   - Match phone number rule
   - Create payment (pending)

3. Background job (2â€“5 sec delay)

4. Auto-resolve payment:
   - success / failed / expired

5. Emit webhook event
âœ” Looks real
âœ” Feels real
âœ” Zero risk
5.4 Fake Webhooks (This Is Important)
Sandbox must still send webhooks.
Example:
Copy code
Json
{
  "event": "payment.successful",
  "livemode": false,
  "data": {
    "id": "pay_test_123",
    "amount": 1500
  }
}
Developers should:
Build logic once
Switch to live later
Nothing breaks
5.5 Sandbox Dashboard (Minimal)
Only show:
API keys
Test logs
Webhook delivery status
Replay webhook button
âŒ No analytics
âŒ No charts
âŒ No noise
Stripe kept dashboards boring on purpose.
5.6 Sandbox Gotchas (Avoid These)
âŒ Donâ€™t make sandbox â€œtoo fakeâ€
âŒ Donâ€™t skip webhook retries
âŒ Donâ€™t behave differently than live
Sandbox â‰  demo
Sandbox = practice environment
How These Two Steps Create a Moat ğŸ§ 
Most African gateways:
Ignore sandbox
Focus on merchants
Break in edge cases
You:
Win developers
Reduce support load
Become default choice
Thatâ€™s how Stripe won.
